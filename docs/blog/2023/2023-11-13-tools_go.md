# Manage Go CLI tools via Go modules and tools.go
> | golang |

## Problem definition

1. Every my Go project has at least two Go CLI tools: [mockery](https://github.com/vektra/mockery) and [golangci-lint](https://github.com/golangci/golangci-lint).
2. These CLI tools might have different version in different repository. I can't use the latest version for any of this tool because it is error prone (i.e. **mockery** generates artifacts differently in a new version; or **golangci-lint** has some new check(s) which fails on my not up to date repos). It means I need to install CLI Go tools globally (see [`GOBIN`](https://pkg.go.dev/cmd/go#hdr-Environment_variables)) and update every projects repo, I've been working with locally, to use tools from `GOBIN`. It's just nightmare to work with and every single CLI tool update it's [PITA](https://www.urbandictionary.com/define.php?term=pita).
3. Ideal solution is to define Go CLI tool per repository like it was done in Node.js, Java (Maven, Gradle), Scala (SBT) and so on. Unfortunately, Go doesn't have built-in solution for dev dependencies. But, we can introduce some conventions which help us to reach our goal.

## Initial thoughts

Basic high-level idea has been described [`tools.go` here][golang/wiki]. Also, I have collected some other `tools.go` variations in [References](#references) section.

Unfortunately, I don't like all of them except [uber]'s really impressive and huge `Makefile`. So, I took it and adjusted it to my own need.

## `tools.go` in action

### Expectations

- clone Go repo
- run test
- all required dependencies will be *downloaded* and *installed* automatically on repo level. Go CLI tools can't collide with any globally installed tools. Repo tools have higher priority then global tools while running them locally from repo's root folder.

### Sample project

You can check demo project here [halyph/demo-tools-go](https://github.com/halyph/demo-tools-go).

```shell
$ tree .
.
├── LICENSE
├── Makefile
├── README.md
├── .bin
│   ├── golangci-lint
│   └── mockery
├── build
│   └── demo
├── cmd
│   └── demo
│       └── main.go
├── go.mod
├── go.sum
├── pkg
│   └── magic
│       ├── magic.go
│       ├── magic_test.go
│       └── mocks
│           └── my_foo.go
└── tools
    ├── go.mod
    ├── go.sum
    └── tools.go
```

- `.bin/` - `make` downloads and installs Go CLI tool in this folder
- `build/` - `make` builds Go application into this folder
- `tools/` - `tools.go` and related `go.mod`
- `pkg/` - location of all Go sources

All other folders and files are pretty standard.

#### Makefile

I show here only essential to `tools.go` **make** targets.

`Makefile` has several important parts:


```makefile
VERSION          := snapshot
NAME             := demo

GIT_HEAD         := $(shell git rev-parse HEAD)
PACKAGES         := $(shell find . -name *.go | grep -v -E "vendor|tools" | xargs -n1 dirname | sort -u)
MAIN_DIR         := ./cmd/$(NAME)
TEST_FLAGS       := -race -count=1 -mod=readonly -cover -coverprofile coverprofile.txt
LINK_FLAGS       := -X main.Version=$(VERSION) -X main.GitHead=$(GIT_HEAD)
BUILD_FLAGS      := -mod=readonly -v

.PHONY: download
download:
	@echo Download go.mod dependencies
	@go mod download

# usually unnecessary to clean, and may require downloads to restore, so this folder is not automatically cleaned
BIN   := $(shell pwd)/.bin
TOOLS := $(shell pwd)/tools

# helper for executing bins, just `$(BIN_PATH) the_command ...`
BIN_PATH := PATH="$(abspath $(BIN)):$$PATH"

.PHONY: install
install: download ## Install useful CLI tools
	@echo Installing tools from $(TOOLS)/tools.go
	@cd $(TOOLS) && cat tools.go | grep _ | awk -F'"' '{print $$2}' | GOBIN=$(BIN) xargs -tI % go install %

.PHONY: default
default: build

.PHONY: generate
generate:
	$(BIN_PATH) go generate $(PACKAGES)

.PHONY: test-generate
test-generate: install generate test

.PHONY: lint
lint: run-lint

.PHONY: test
test: run-lint run-test

.PHONY: build
build:
	CGO_ENABLED=0 go build $(BUILD_FLAGS) -ldflags="$(LINK_FLAGS)" -o build/$(NAME) $(MAIN_DIR)
	@echo build complete

.PHONY: clean
clean:
	rm -rvf pkg/mocks build coverprofile.txt

.PHONY: run-lint
run-lint:
	$(BIN_PATH) golangci-lint --version
	$(BIN_PATH) golangci-lint run $(PACKAGES)

.PHONY: run-test
run-test:
	go test $(TEST_FLAGS) $(PACKAGES)
```

## References

- **Articles**:
  - [*"Manage Go tools via Go modules"* by Marco Franssen, 2019](https://marcofranssen.nl/manage-go-tools-via-go-modules)
  - [*"Need to Version Go Tools for Your Project? That's a Bingo!"* by Bartek Płotka, 2020](https://www.bwplotka.dev/2020/bingo/)
  - [*"How to use go run to manage tool dependencies"* by Alex Edwards, 2022](https://www.alexedwards.net/blog/using-go-run-to-manage-tool-dependencies)
  - [*"Golang Tools as Dependencies"* by YC, 2022](https://www.tiredsg.dev/blog/golang-tools-as-dependencies/)
  - [*"Managing your Go tool versions with go.mod and a tools.go"* by Jamie Tanna, 2022](https://www.jvt.me/posts/2022/06/15/go-tools-dependency-management/)
  - [`go-modules-by-example` - Tools as dependencies](https://github.com/go-modules-by-example/index/blob/master/010_tools/README.md#tools-as-dependencies)
  - [`golang/wiki` - How can I track tool dependencies for a module?][golang/wiki]
  - [`go/build` - Build Constraints](https://pkg.go.dev/go/build#hdr-Build_Constraints)
- Repos:
  - ❤️ [uber/cadence/Makefile][uber] advance `tools.go` sample 
  - [`cmd/go`: track tool dependencies in go.mod](https://github.com/golang/go/issues/48429)

[golang/wiki]: https://github.com/golang/go/wiki/Modules#how-can-i-track-tool-dependencies-for-a-module "`golang/wiki` - How can I track tool dependencies for a module?"
[uber]: https://github.com/uber/cadence/blob/a253154e59d04048ea3aa6d77242d1a412b86688/Makefile "uber/cadence/Makefile"
